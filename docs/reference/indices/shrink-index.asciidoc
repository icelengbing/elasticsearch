[[indices-shrink-index]]
== 收缩索引

收缩索引 API 允许您将现有索引收缩为具有较少主分片的新索引。目标索引的主分片数必须是源索引分片数的一个因子。例如，带有 `8` 个主分片的索引可以收缩为 `4`、`2` 或者 `1` 个主分片，或者带有 `15` 个主分片的索引可以收缩为 `5`、`3` 或者 `1` 个主分片。如果索引中的分片数是素数，则其只能收缩为单个主分片。在收缩之前，索引中每个分片（主分片或者副本）都必须存在于同一节点上。

收缩的工作原理如下：

* 首先，创建一个新的目标索引，其定义与源索引相同，但主分片数量较少。

* 然后，将源索引中的段硬链接到目标索引。 （如果文件系统不支持硬链接，则会将所有段复制到新索引中，这是一个更耗时的过程。）

* 最后，恢复目标索引，就好像刚打开一个曾经关闭的索引。

[float]
=== 准备收缩索引

为了收缩索引，必须将索引标记为只读，并且索引中每个分片（主分片或者副本）都必须重定位到同一节点，同时集群健康状态 <<cluster-health,health>> 必须是 `green` 。

可以通过以下请求实现上述两个条件：

[source,js]
--------------------------------------------------
PUT /my_source_index/_settings
{
  "settings": {
    "index.routing.allocation.require._name": "shrink_node_name", <1>
    "index.blocks.write": true <2>
  }
}
--------------------------------------------------
// CONSOLE
// TEST[s/^/PUT my_source_index\n/]
<1> 强制将每个分片定位到名为 `shrink_node_name` 的节点。更多选项可参阅 <<shard-allocation-filtering>> 。

<2> 阻止对索引的写入操作，但是仍允许更改元数据，例如删除索引。

重新定位源索引可能需要一段时间。可以使用 <<cat-recovery,`_cat recovery` API>> 跟踪进度，或者使用带 `wait_for_no_relocating_shards` 参数的 <<cluster-health,
`cluster health` API>> 来监控是否所有分片都已经被重定位。

[float]
=== 收缩索引

要将索引 `my_source_index` 收缩为索引 `my_target_index` ，可以通过如下请求：

[source,js]
--------------------------------------------------
POST my_source_index/_shrink/my_target_index?copy_settings=true
{
  "settings": {
    "index.routing.allocation.require._name": null, <1>
    "index.blocks.write": null <2>
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

<1> 清除从源索引复制来的重定位分片属性。
<2> 清除从源索引复制来的阻止写请求设置。

目标索引添加到集群状态后，上述请求会立即返回 -- 它不会等待收缩操作开始。

[IMPORTANT]
=====================================

索引只有满足以下要求才能被收缩：

* 目标索引不存在。

* 索引的主分片数必须比目标索引多。

* 目标索引中的主分片数必须是源索引中主分片数的一个因子。源索引必须具有比目标索引更多的主分片。

* 所有分片中的文档总数不得超过 `2,147,483,519` ，因为这些分片将收缩到目标索引上的单个分片，而上述数字是单个分片的最大文档数。

* 处理收缩过程的节点上必须有足够的可用磁盘空间，以便容纳现有索引的第二个拷贝。

=====================================

`_shrink` API 类似于 <<indices-create-index, `create index` API>>  并且接受目标索引的 `settings` 和 `aliases` 参数：

[source,js]
--------------------------------------------------
POST my_source_index/_shrink/my_target_index?copy_settings=true
{
  "settings": {
    "index.number_of_replicas": 1,
    "index.number_of_shards": 1, <1>
    "index.codec": "best_compression" <2>
  },
  "aliases": {
    "my_search_indices": {}
  }
}
--------------------------------------------------
// CONSOLE
// TEST[s/^/PUT my_source_index\n{"settings": {"index.blocks.write": true}}\n/]

<1> 目标索引中的分片数必须是源索引中分片数的一个因子。
<2> 最大压缩参数只会对新写入索引的数据生效，例如当 <<indices-forcemerge,force-merging>> 分片到单个段时。


NOTE: 不可以在 `_shrink` 请求中指定映射。

NOTE: 默认情况下，除了 `index.analysis`、`index.similarity` 和 `index.sort` 设置外，源索引上的其它索引设置不会在收缩操作时被复制。除了不可复制的设置之外，可以通过在请求中添加 URL 参数 `copy_settings=true` 来将源索引中的设置复制到目标索引中。需要注意，`copy_settings` 不能设置为 `false`。参数 `copy_settings` 将在8.0.0中删除

deprecated[6.4.0，不推荐复制设置，复制设置将是7.x中的默认行为]

[float]
=== 监控收缩过程

可以使用 <<cat-recovery,`_cat recovery` API>> 监控收缩过程，或者通过设置参数 `wait_for_status` 为 `yellow` 的 <<cluster-health, `cluster health` API>> 来监控是否所有主分片都已经分配。

在分配任何分片之前，只要目标索引已添加到群集状态，`_shrink` API 就会返回。此时，所有分片都处于 `unassigned` 状态。如果由于任何原因无法在收缩节点上分配目标索引，则其主分片将保持 `unassigned` ，直到可以在该节点上分配为止。

一旦分配了主分片，状态就会变为 `initializing` ，然后开始执行收缩过程。当操作完成时，分片将变为 `active` 状态。同时，Elasticsearch 将尝试分配副本，并可能将主分片重定位到另外的节点。

[float]
=== 等待活动分片

由于收缩操作会创建一个新的索引来减少分片，因此索引创建的设置 <<create-index-wait-for-active-shards,wait for active shards>> 也适用于收缩索引操作。
