[[indices-rollover-index]]
== 滚动索引

当一个索引太大或者太旧时，可以使用滚动索引 API 将别名转移到一个新索引上。

此 API 接收单个别名和一个 `conditions` 列表。别名必须指定一个写入索引。有以下两种方法可以采用，根据不同的配置，别名的元数据将会以不同的方式被更新。这两种场景如下：

 - 别名仅指向未配置 `is_write_index` 的单个索引（默认为 `null`）。

在这种场景下，原索引将其滚动别名添加到新创建的索引中，然后从原索引中删除。

 - 别名指向一个或多个索引，其中 `is_write_index` 属性在要滚动的索引（写入索引）上设置为`true`。

在这种场景下，写入索引将其滚动别名属性 `is_write_index` 设置为 `false` ，而新创建的索引现在将滚动别名指向它作为写入索引，并将 `is_write_index` 设置为 `true` 。


[source,js]
--------------------------------------------------
PUT /logs-000001 <1>
{
  "aliases": {
    "logs_write": {}
  }
}

# Add > 1000 documents to logs-000001

POST /logs_write/_rollover <2>
{
  "conditions": {
    "max_age":   "7d",
    "max_docs":  1000,
    "max_size":  "5gb"
  }
}
--------------------------------------------------
// CONSOLE
// TEST[setup:huge_twitter]
// TEST[s/# Add > 1000 documents to logs-000001/POST _reindex?refresh\n{"source":{"index":"twitter"},"dest":{"index":"logs-000001"}}/]
<1> 创建一个名为 `logs-0000001` 的索引并关联别名 `logs_write` 。
<2> 如果 `logs_write` 指向的索引是7天或更久以前创建的，或者包含至少1000个文档，或者索引大小超过5GB，则创建索引 `logs-000002` 并且关联别名 `logs_write` 。

上述请求可能会返回以下响应：

[source,js]
--------------------------------------------------
{
  "acknowledged": true,
  "shards_acknowledged": true,
  "old_index": "logs-000001",
  "new_index": "logs-000002",
  "rolled_over": true, <1>
  "dry_run": false, <2>
  "conditions": { <3>
    "[max_age: 7d]": false,
    "[max_docs: 1000]": true,
    "[max_size: 5gb]": false,
  }
}
--------------------------------------------------
// TESTRESPONSE
<1> 索引是否已经滚动。
<2> 滚动是否是演练模式。
<3> 每个条件的结果。

[float]
=== 命名新索引

如果现存索引的名称以 `-` 和数字结尾 -- 例如：`logs-000001` -- 则后续新索引将会遵循相同的命名模式递增数字(`logs-000002`)。名称后的数字以零填充，长度为6。

如果旧索引名称与上述模式不匹配，则必须指定新索引的名称，如下所示：

[source,js]
--------------------------------------------------
POST /my_alias/_rollover/my_new_index_name
{
  "conditions": {
    "max_age":   "7d",
    "max_docs":  1000,
    "max_size": "5gb"
  }
}
--------------------------------------------------
// CONSOLE
// TEST[s/^/PUT my_old_index_name\nPUT my_old_index_name\/_alias\/my_alias\n/]

[float]
=== 使用日期计算的滚动 API

使用 <<date-math-index-names,date math>> 来命名根据日期滚动的滚动索引是很方便的。例如： `logstash-2016.02.03`。滚动 API 支持日期计算，但是要求索引名必须以短划线后跟数字结尾，例如： `logstash-2016.02.03-1` ，每次滚动索引时都会递增，案例如下：

[source,js]
--------------------------------------------------
# PUT /<logs-{now/d}-1> with URI encoding:
PUT /%3Clogs-%7Bnow%2Fd%7D-1%3E <1>
{
  "aliases": {
    "logs_write": {}
  }
}

PUT logs_write/_doc/1
{
  "message": "a dummy log"
}

POST logs_write/_refresh

# Wait for a day to pass

POST /logs_write/_rollover <2>
{
  "conditions": {
    "max_docs":   "1"
  }
}
--------------------------------------------------
// CONSOLE
// TEST[s/now/2016.10.31||/]
<1> 创建一个以今天的日期命名的索引（例如） `logs-2016.10.31-1`
<2> 使用今天的日期滚动到新索引，例如：如果立刻运行，名称为 `logs-2016.10.31-000002` ，或者24小时后运行，名称为 `logs-2016.11.01-000002`

//////////////////////////

[source,js]
--------------------------------------------------
GET _alias
--------------------------------------------------
// CONSOLE
// TEST[continued]

[source,js]
--------------------------------------------------
{
  "logs-2016.10.31-000002": {
    "aliases": {
      "logs_write": {}
    }
  },
  "logs-2016.10.31-1": {
    "aliases": {}
  }
}
--------------------------------------------------
// TESTRESPONSE

//////////////////////////

可以根据 <<date-math-index-names,date math documentation>> 的描述来引用索引。例如：要搜索过去三天创建的索引，你可以执行以下操作：

[source,js]
--------------------------------------------------
# GET /<logs-{now/d}-*>,<logs-{now/d-1d}-*>,<logs-{now/d-2d}-*>/_search
GET /%3Clogs-%7Bnow%2Fd%7D-*%3E%2C%3Clogs-%7Bnow%2Fd-1d%7D-*%3E%2C%3Clogs-%7Bnow%2Fd-2d%7D-*%3E/_search
--------------------------------------------------
// CONSOLE
// TEST[continued]
// TEST[s/now/2016.10.31||/]

[float]
=== 定义新索引

新索引的设置、映射和别名参考  <<indices-templates,index templates>> 。此外，你也可以在请求正文中指定`设置`、`映射`和`别名`，就像 <<indices-create-index,create index>> API 一样。请求中指定的参数值会覆盖索引模板中相同的设置。例如：以下 `rollover` 请求会覆盖 `index.number_of_shards` 的设置：

[source,js]
--------------------------------------------------
PUT /logs-000001
{
  "aliases": {
    "logs_write": {}
  }
}

POST /logs_write/_rollover
{
  "conditions" : {
    "max_age": "7d",
    "max_docs": 1000,
    "max_size": "5gb"
  },
  "settings": {
    "index.number_of_shards": 2
  }
}
--------------------------------------------------
// CONSOLE

[float]
=== 演练

滚动 API 支持 `dry_run` 模式，可以在不执行实际滚动操作的情况下检查请求条件：

[source,js]
--------------------------------------------------
PUT /logs-000001
{
  "aliases": {
    "logs_write": {}
  }
}

POST /logs_write/_rollover?dry_run
{
  "conditions" : {
    "max_age": "7d",
    "max_docs": 1000,
    "max_size": "5gb"
  }
}
--------------------------------------------------
// CONSOLE

[float]
=== 等待活动分片

因为滚动操作会创建一个新的索引，所以索引创建的属性  <<create-index-wait-for-active-shards,`wait_for_active_shards`>> 设置也适用于滚动操作。

[[indices-rollover-is-write-index]]
[float]
=== 写索引别名行为

在滚动操作期间，不会交换一个显示设置了 `is_write_index` 属性为 `true` 的写入索引的滚动别名。如果一个别名指向多个索引，由于无法明确的识别哪个索引是正确的写入索引，因此滚动操作如果指向一个关联多个索引的别名是无效的。所以，默认行为是交换面向写入别名指向的索引。在上面的例子中是指 `logs_write`。由于设置 `is_write_index` 可以使别名能够指向多个索引，同时也显示的指明滚动操作时的目标索引，所以没有必要从滚动索引中删除别名。这样就可以通过允许一个别名同时作为索引的读、写别名来简化滚动操作的管理过程。

查看以下范例中别名的用法，滚动索引上设置了 `is_write_index` 属性。

[source,js]
--------------------------------------------------
PUT my_logs_index-000001
{
  "aliases": {
    "logs": { "is_write_index": true } <1>
  }
}

PUT logs/_doc/1
{
  "message": "a dummy log"
}

POST logs/_refresh

POST /logs/_rollover
{
  "conditions": {
    "max_docs":   "1"
  }
}

PUT logs/_doc/2 <2>
{
  "message": "a newer log"
}
--------------------------------------------------
// CONSOLE
<1> 配置 `my_logs_index` 作为别名 `logs` 的写入索引
<2> 针对别名 `logs` 将新建文档写入新索引

[source,js]
--------------------------------------------------
{
  "_index" : "my_logs_index-000002",
  "_type" : "_doc",
  "_id" : "2",
  "_version" : 1,
  "result" : "created",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 0,
  "_primary_term" : 1
}
--------------------------------------------------
// TESTRESPONSE

//////////////////////////
[source,js]
--------------------------------------------------
GET _alias
--------------------------------------------------
// CONSOLE
// TEST[continued]
//////////////////////////

滚动操作后，两个索引的别名元数据中都将含有 `is_write_index` 设置来表明各自的角色，可以看到新建索引是写入索引。

[source,js]
--------------------------------------------------
{
  "my_logs_index-000002": {
    "aliases": {
      "logs": { "is_write_index": true }
    }
  },
  "my_logs_index-000001": {
    "aliases": {
      "logs": { "is_write_index" : false }
    }
  }
}
--------------------------------------------------
// TESTRESPONSE
